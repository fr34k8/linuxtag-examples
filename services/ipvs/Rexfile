use Rex -base;
use Data::Dumper;
use JSON::XS;


user "root";
password "test";

pass_auth;

include 'Rex::DNS::Bind';

set dns => {
   server   => "127.0.0.1",
   key      => "IQGzNua9bGZAecUU3pmLLw==",
   key_name => "rexio",
};

task "setup", sub {

   my $op       = operating_system;
   my $packages = case $op, {
                    Debian => ["ipvsadm","ldirectord"],
                    Ubuntu => ["ipvsadm","ldirectord"],
                 };

   install $packages;

   file "/etc/modules",
      source => "files/$op/etc/modules";

   for (split(/\n/, cat "/etc/modules")) {
      next if (/^$/ || /^\s*$/ || /^#/);
      kmod load => $_;
   }

   file "/etc/sysctl.conf",
      source => "files/$op/etc/sysctl.conf";

   run "sysctl -p";

   write_ldirectory_conf();
};

task "setup_node", sub {

   my $op       = operating_system;
   my %info = get_system_information;

   my $packages = case $op, {
                     Debian => ["iproute"],
                     Ubuntu => ["iproute"],
                  };

   my @dns_entries = Rex::DNS::Bind::list_entries({
      domain => $info{domain},
   });

   my ($txt) = grep { 
                         ($_->{name} eq "$info{hostname}.$info{domain}")
                      && ($_->{type} eq "TXT")
                     } @dns_entries;

   my $ref;
   eval {
      $ref  = decode_json($txt->{data});
   } or do {
      # this is really strange... must be a bug in Net::DNS
      eval {
         $ref = decode_json(substr($txt->{data}, 1));
      } or do {
         print "Can't decode json: $@\n";
         die;
      };
   };

   # {"vh":["www.stage.rexify.org"],"ld":["www.stage.rexify.org"]}

   file "/etc/sysctl.conf",
      source => "files/$op/etc/sysctl.conf.node";

   run "sysctl -p";

   for my $vhost (@{ $ref->{ld} }) {
      ($vhost) = grep { ($_->{type} eq "A" && $_->{name} eq $vhost) ? $_ = $_->{data} : undef } @dns_entries;
   }

   file "/etc/network/interfaces",
      content => template("files/$op/etc/network/interfaces.node",
                    config => $ref->{ld},
                 );
    
    # sometimes it is better to do it twice...
    # especially if ip changed
    my $i = 0;
    for (@{ $ref->{ld} }) {
       run "ifup lo:$i";
       run "ifdown lo:$i";
       run "ifup lo:$i";
       $i++;
    }

};


task "write_ldirectory_conf", sub {

   my $op = operating_system;
   my %info = get_system_information;

   my @dns_entries = Rex::DNS::Bind::list_entries({
      domain => $info{domain},
   });

   my ($txt) = grep { 
                         ($_->{name} eq "$info{hostname}.$info{domain}")
                      && ($_->{type} eq "TXT")
                     } @dns_entries;

   my $ref;
   eval {
      $ref  = decode_json($txt->{data});
   } or do {
      # this is really strange... must be a bug in Net::DNS
      eval {
         $ref = decode_json(substr($txt->{data}, 1));
      } or do {
         print "Can't decode json: $@\n";
         die;
      };
   };

   # {"ld":{"192.168.7.101:80": "fe\\d+"},"hb":"db01"}

   my %ld_service;

   for my $entry (@dns_entries) {
      next if ($entry->{type} ne "A");

      for my $service (keys %{ $ref->{ld} }) {
         my ($port) = ($service =~ m/:(\d+)$/);
         if($entry->{name} =~ $ref->{ld}->{$service}) {
            push @{$ld_service{$service}}, $entry->{data}. ":$port";
         }
      }
   }

   file "/etc/ha.d/ldirectord.cf",
      content => template("files/$op/etc/ha.d/ldirectord.cf",
                    services => \%ld_service
                 );

};


